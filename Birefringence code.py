{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "5a056299",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Selected RGB Values: [(235, 77, 9), (187, 58, 4), (118, 95, 56)]\n",
      "Calculated Birefringence Values: [array(0.05487164), array(0.04276783), array(0.0405941)]\n",
      "Point 1: RGB: (235, 77, 9), Birefringence: 0.054871642027310645\n",
      "Point 2: RGB: (187, 58, 4), Birefringence: 0.04276783285213276\n",
      "Point 3: RGB: (118, 95, 56), Birefringence: 0.040594098661189154\n"
     ]
    }
   ],
   "source": [
    "import cv2\n",
    "import numpy as np\n",
    "from skimage import color\n",
    "from scipy.interpolate import interp1d\n",
    "\n",
    "# Michel-Levy chart with RGB-to-birefringence mapping (simplified)\n",
    "michel_levy_data = {\n",
    "    (236, 72, 8): 0.055,   # Red\n",
    "    (255, 165, 0): 0.05,   # Orange\n",
    "    (255, 255, 0): 0.045,  # Yellow\n",
    "    (0, 255, 0): 0.04,     # Green\n",
    "    (0, 0, 255): 0.03      # Blue\n",
    "}\n",
    "\n",
    "# Convert RGB values to Lab using skimage\n",
    "michel_levy_rgb = np.array(list(michel_levy_data.keys()))\n",
    "michel_levy_biref = np.array(list(michel_levy_data.values()))\n",
    "\n",
    "# Convert RGB values to Lab space for interpolation (Lab color space is perceptually uniform)\n",
    "lab_colors = np.array([color.rgb2lab(np.array([[rgb]]) / 255.0)[0][0] for rgb in michel_levy_rgb])\n",
    "\n",
    "# Helper function to calculate mean RGB values from an image\n",
    "def get_mean_rgb(img, center, radius=10):\n",
    "    \"\"\"Extracts the mean RGB value from a circular region.\"\"\"\n",
    "    mask = np.zeros(img.shape[:2], dtype=np.uint8)\n",
    "    cv2.circle(mask, center, radius, (255, 255, 255), -1)\n",
    "    mean_val = cv2.mean(img, mask=mask)[:3]  # Extract BGR values\n",
    "    return (int(mean_val[2]), int(mean_val[1]), int(mean_val[0]))  # Convert BGR to RGB\n",
    "\n",
    "# Function to find birefringence for a given RGB value using interpolation\n",
    "def interpolate_birefringence(rgb):\n",
    "    \"\"\"Interpolate the birefringence value for a given RGB using linear interpolation.\"\"\"\n",
    "    # Convert RGB to Lab for interpolation\n",
    "    lab_color = color.rgb2lab(np.array([[rgb]]) / 255.0)[0][0]\n",
    "    \n",
    "    # Interpolate Lab space, and then convert it back to RGB and birefringence\n",
    "    interp_func = interp1d(lab_colors[:, 0], michel_levy_biref, kind='linear', fill_value=\"extrapolate\")\n",
    "    biref = interp_func(lab_color[0])  # Interpolate based on the L channel (luminance)\n",
    "    return biref\n",
    "\n",
    "# Function to handle mouse click event and capture points\n",
    "def click_event(event, x, y, flags, param):\n",
    "    \"\"\"Handles mouse click events for point selection.\"\"\"\n",
    "    global points, img\n",
    "    if event == cv2.EVENT_LBUTTONDOWN:\n",
    "        points.append((x, y))\n",
    "        cv2.circle(img, (x, y), 10, (0, 0, 255), 2)\n",
    "        cv2.imshow('Select Color', img)\n",
    "        \n",
    "        if len(points) == 3:\n",
    "            cv2.destroyAllWindows()\n",
    "\n",
    "# Main function to process the image\n",
    "def process_image(image_path):\n",
    "    \"\"\"Load the image, capture points, and calculate birefringence.\"\"\"\n",
    "    global img, points\n",
    "    points = []\n",
    "\n",
    "    # Load image\n",
    "    img = cv2.imread(image_path)\n",
    "    \n",
    "    # Check if image is loaded correctly\n",
    "    if img is None:\n",
    "        print(\"Error: Input image not loaded correctly.\")\n",
    "        return\n",
    "    \n",
    "    cv2.imshow('Select Color', img)\n",
    "    cv2.setMouseCallback('Select Color', click_event)\n",
    "    cv2.waitKey(0)\n",
    "    cv2.destroyAllWindows()\n",
    "\n",
    "    # Ensure exactly 3 points are selected\n",
    "    if len(points) != 3:\n",
    "        print(\"Error: Please select exactly 3 points.\")\n",
    "        return\n",
    "    \n",
    "    # Extract RGB values and calculate birefringence\n",
    "    rgb_values = [get_mean_rgb(img, p) for p in points]\n",
    "    birefringences = [interpolate_birefringence(rgb) for rgb in rgb_values]\n",
    "\n",
    "    print(\"Selected RGB Values:\", rgb_values)\n",
    "    print(\"Calculated Birefringence Values:\", birefringences)\n",
    "\n",
    "    return birefringences, rgb_values\n",
    "\n",
    "# Path to the image\n",
    "image_path = \"C:/Users/LENOVO/Downloads/Voltage.jpg\"  # Update with the correct image path\n",
    "\n",
    "# Process the image\n",
    "birefringences, rgb_values = process_image(image_path)\n",
    "\n",
    "# Display the results (debugging purpose)\n",
    "if birefringences and rgb_values:\n",
    "    for i, (rgb, biref) in enumerate(zip(rgb_values, birefringences)):\n",
    "        print(f\"Point {i+1}: RGB: {rgb}, Birefringence: {biref}\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "54507710",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
